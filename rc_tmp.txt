
/**
 * Reservation controller
 */

import { success, error } from '../utils/response.js';
import { query } from '../config/database.js';
import { v4 as uuidv4 } from 'uuid';
import { issueCouponsForTrigger } from '../services/couponAutoIssue.js';

const toMySQLDateTime = (dateString) => {
  if (!dateString) return null;
  const date = new Date(dateString);
  return date.toISOString().slice(0, 19).replace('T', ' ');
};

const ALLOWED_STATUSES = ['pending', 'pending_approval', 'confirmed', 'rejected', 'in_progress', 'completed', 'cancelled'];
const ALLOWED_STORAGE_TYPES = ['s', 'm', 'l', 'xl', 'special', 'refrigeration'];

export const createReservation = async (req, res) => {
  try {
    const storeId = req.storeId || req.body.storeId;
    const {
      customerName,
      phoneNumber,
      email,
      startTime,
      endTime,
      duration,
      price,
      bagCount,
      message,
      specialRequests,
      luggageImageUrls,
      paymentMethod = 'card',
      requestTime,
      storageType,
    } = req.body;

    if (!customerName || !phoneNumber || !startTime || !duration || !bagCount || !storeId || !storageType) {
      return res.status(400).json(
        error('VALIDATION_ERROR', '?„ìˆ˜ ?•ë³´ê°€ ?„ë½?˜ì—ˆ?µë‹ˆ??, {
          required: ['storeId', 'customerName', 'phoneNumber', 'startTime', 'duration', 'bagCount', 'storageType'],
        })
      );
    }

    if (!ALLOWED_STORAGE_TYPES.includes(storageType)) {
      return res
        .status(400)
        .json(error('VALIDATION_ERROR', '?ˆìš©?˜ì? ?ŠëŠ” ë³´ê????€?…ì…?ˆë‹¤', { allowed: ALLOWED_STORAGE_TYPES }));
    }

    const reservationId = `res_${uuidv4()}`;
    let calculatedEndTime = endTime;
    if (!calculatedEndTime && startTime && duration) {
      const start = new Date(startTime);
      start.setHours(start.getHours() + Number(duration));
      calculatedEndTime = start.toISOString();
    }

    const customerId = req.customerId || req.body.customerId || `cust_${Date.now()}`;

    await query(
      `INSERT INTO reservations (
         id, store_id, customer_id, customer_name, customer_phone, customer_email,
         storage_id, storage_number, requested_storage_type,
         status, start_time, end_time, request_time, actual_start_time, actual_end_time,
         duration, bag_count, total_amount, message, special_requests, luggage_image_urls,
         payment_status, payment_method, qr_code, created_at, updated_at
       ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())`,
      [
        reservationId,
        storeId,
        customerId,
        customerName,
        phoneNumber,
        email || null,
        null, // storage_id
        null, // storage_number
        storageType,
        'pending',
        toMySQLDateTime(startTime),
        toMySQLDateTime(calculatedEndTime),
        toMySQLDateTime(requestTime || new Date().toISOString()),
        null, // actual_start_time
        null, // actual_end_time
        duration,
        bagCount,
        price || 0,
        message || null,
        specialRequests || null,
        luggageImageUrls ? JSON.stringify(luggageImageUrls) : null,
        'pending',
        paymentMethod,
        null, // qr_code
      ]
    );

    const [newReservation] = await query(
      `SELECT
         id, store_id as storeId, customer_id as customerId,
         customer_name as customerName, customer_phone as phoneNumber,
         customer_email as email, status, start_time as startTime,
         end_time as endTime, request_time as requestTime, duration,
         bag_count as bagCount, total_amount as price, message, storage_id as storageId, storage_number as storageNumber,
         requested_storage_type as storageType,
         special_requests as specialRequests, payment_status as paymentStatus,
         payment_method as paymentMethod, created_at as createdAt
       FROM reservations WHERE id = ?`,
      [reservationId]
    );

    return res.status(201).json(success(newReservation, '?ˆì•½???ì„±?˜ì—ˆ?µë‹ˆ??));
  } catch (err) {
    console.error('[createReservation] error:', err);
    return res.status(500).json(error('INTERNAL_ERROR', '?œë²„ ?¤ë¥˜ê°€ ë°œìƒ?ˆìŠµ?ˆë‹¤', { message: err.message }));
  }
};

export const getReservations = async (req, res) => {
  try {
    const storeId = req.storeId;
    const { status, date, customerId, page = 1, limit = 20 } = req.query;

    const conditions = ['store_id = ?'];
    const params = [storeId];
    if (status) {
      conditions.push('status = ?');
      params.push(status);
    }
    if (date) {
      conditions.push('DATE(start_time) = ?');
      params.push(date);
    }
    if (customerId) {
      conditions.push('customer_id = ?');
      params.push(customerId);
    }
    const whereClause = conditions.join(' AND ');

    const countResult = await query(`SELECT COUNT(*) as total FROM reservations WHERE ${whereClause}`, params);
    const totalItems = countResult[0]?.total || 0;
    const offset = (Number(page) - 1) * Number(limit);

    const rows = await query(
      `SELECT
         id, store_id as storeId, customer_id as customerId,
         customer_name as customerName, customer_phone as phoneNumber,
         customer_email as email, status, start_time as startTime,
         end_time as endTime, request_time as requestTime, duration,
         bag_count as bagCount, total_amount as price, message, storage_id as storageId, storage_number as storageNumber,
         requested_storage_type as storageType,
         special_requests as specialRequests, payment_status as paymentStatus,
         payment_method as paymentMethod, created_at as createdAt
       FROM reservations
       WHERE ${whereClause}
       ORDER BY created_at DESC
       LIMIT ? OFFSET ?`,
      [...params, Number(limit), offset]
    );

    return res.json(
      success({
        items: rows,
        page: Number(page),
        limit: Number(limit),
        total: totalItems,
      })
    );
  } catch (err) {
    console.error('[getReservations] error:', err);
    return res.status(500).json(error('INTERNAL_ERROR', '?œë²„ ?¤ë¥˜ê°€ ë°œìƒ?ˆìŠµ?ˆë‹¤', { message: err.message }));
  }
};

export const getReservation = async (req, res) => {
  try {
    const storeId = req.storeId;
    const { id } = req.params;
    const rows = await query(
      `SELECT
         id, store_id as storeId, customer_id as customerId,
         customer_name as customerName, customer_phone as phoneNumber,
         customer_email as email, status, start_time as startTime,
         end_time as endTime, request_time as requestTime, duration,
         bag_count as bagCount, total_amount as price, message, storage_id as storageId, storage_number as storageNumber,
         requested_storage_type as storageType,
         special_requests as specialRequests, payment_status as paymentStatus,
         payment_method as paymentMethod, created_at as createdAt
       FROM reservations
       WHERE id = ? AND store_id = ? LIMIT 1`,
      [id, storeId]
    );
    if (!rows || rows.length === 0) {
      return res.status(404).json(error('RESERVATION_NOT_FOUND', '?ˆì•½??ì°¾ì„ ???†ìŠµ?ˆë‹¤'));
    }
    return res.json(success(rows[0]));
  } catch (err) {
    console.error('[getReservation] error:', err);
    return res.status(500).json(error('INTERNAL_ERROR', '?œë²„ ?¤ë¥˜ê°€ ë°œìƒ?ˆìŠµ?ˆë‹¤', { message: err.message }));
  }
};

// ê³ ê°?? ë¡œê·¸??ê³ ê°???ˆì•½ ëª©ë¡ ì¡°íšŒ
export const getCustomerReservations = async (req, res) => {
  try {
    const customerId = req.customerId;
    const { status, date, storeId, page = 1, limit = 20 } = req.query;

    const conditions = ['customer_id = ?'];
    const params = [customerId];
    if (storeId) {
      conditions.push('store_id = ?');
      params.push(storeId);
    }
    if (status) {
      conditions.push('status = ?');
      params.push(status);
    }
    if (date) {
      conditions.push('DATE(start_time) = ?');
      params.push(date);
    }
    const whereClause = conditions.join(' AND ');

    const countResult = await query(`SELECT COUNT(*) as total FROM reservations WHERE ${whereClause}`, params);
    const totalItems = countResult[0]?.total || 0;
    const offset = (Number(page) - 1) * Number(limit);

    const rows = await query(
      `SELECT
         id, store_id as storeId, customer_id as customerId,
         customer_name as customerName, customer_phone as phoneNumber,
         customer_email as email, status, start_time as startTime,
         end_time as endTime, request_time as requestTime, duration,
         bag_count as bagCount, total_amount as price, message,
         storage_id as storageId, storage_number as storageNumber,
         requested_storage_type as storageType,
         special_requests as specialRequests, payment_status as paymentStatus,
         payment_method as paymentMethod, created_at as createdAt
       FROM reservations
       WHERE ${whereClause}
       ORDER BY created_at DESC
       LIMIT ? OFFSET ?`,
      [...params, Number(limit), offset]
    );

    return res.json(
      success({
        items: rows,
        page: Number(page),
        limit: Number(limit),
        total: totalItems,
      })
    );
  } catch (err) {
    console.error('[getCustomerReservations] error:', err);
    return res.status(500).json(error('INTERNAL_ERROR', '?œë²„ ?¤ë¥˜ê°€ ë°œìƒ?ˆìŠµ?ˆë‹¤', { message: err.message }));
  }
};

// ê³ ê°?? ë¡œê·¸??ê³ ê°???ˆì•½ ?¨ê±´ ì¡°íšŒ
export const getCustomerReservation = async (req, res) => {
  try {
    const customerId = req.customerId;
    const { id } = req.params;
    const rows = await query(
      `SELECT
         id, store_id as storeId, customer_id as customerId,
         customer_name as customerName, customer_phone as phoneNumber,
         customer_email as email, status, start_time as startTime,
         end_time as endTime, request_time as requestTime, duration,
         bag_count as bagCount, total_amount as price, message,
         storage_id as storageId, storage_number as storageNumber,
         requested_storage_type as storageType,
         special_requests as specialRequests, payment_status as paymentStatus,
         payment_method as paymentMethod, created_at as createdAt
       FROM reservations
       WHERE id = ? AND customer_id = ? LIMIT 1`,
      [id, customerId]
    );
    if (!rows || rows.length === 0) {
      return res.status(404).json(error('RESERVATION_NOT_FOUND', '?ˆì•½??ì°¾ì„ ???†ìŠµ?ˆë‹¤'));
    }
    return res.json(success(rows[0]));
  } catch (err) {
    console.error('[getCustomerReservation] error:', err);
    return res.status(500).json(error('INTERNAL_ERROR', '?œë²„ ?¤ë¥˜ê°€ ë°œìƒ?ˆìŠµ?ˆë‹¤', { message: err.message }));
  }
};

// ê³ ê° ì²´í¬?„ì›ƒ: ?íƒœë¥?completedë¡??„í™˜, ?¤ì œ ì¢…ë£Œ ?œê°„ ê¸°ë¡, ë³´ê???ë°˜ë‚©
export const customerCheckout = async (req, res) => {
  try {
    const customerId = req.customerId;
    const { id } = req.params;
    const reservation = await findCustomerReservation(id, customerId);
    if (!reservation) {
      return res.status(404).json(error('RESERVATION_NOT_FOUND', '?ˆì•½??ì°¾ì„ ???†ìŠµ?ˆë‹¤'));
    }
    if (reservation.status !== 'in_progress' && reservation.status !== 'confirmed') {
      return res
        .status(400)
        .json(error('INVALID_STATUS', 'ì²´í¬?„ì›ƒ ê°€?¥í•œ ?íƒœê°€ ?„ë‹™?ˆë‹¤', { currentStatus: reservation.status }));
    }

    await query(
      `UPDATE reservations
       SET status = 'completed', actual_end_time = NOW(), updated_at = NOW()
       WHERE id = ? AND customer_id = ?`,
      [id, customerId]
    );

    if (reservation.storage_id) {
      await query('UPDATE storages SET status = ? WHERE id = ?', ['available', reservation.storage_id]);
    }

    // ?ë™ ë°œê¸‰ ?? ?ˆì•½ ?„ë£Œ
    try {
      await issueCouponsForTrigger({
        customerId,
        storeId: reservation.store_id,
        trigger: 'reservation_completed',
        reservationId: reservation.id,
      });
    } catch (hookErr) {
      console.warn('[customerCheckout] auto issue skipped:', hookErr?.message);
    }

    return res.json(success({ id, status: 'completed' }, 'ì²´í¬?„ì›ƒ ?„ë£Œ'));
  } catch (err) {
    console.error('[customerCheckout] error:', err);
    return res.status(500).json(error('INTERNAL_ERROR', '?œë²„ ?¤ë¥˜ê°€ ë°œìƒ?ˆìŠµ?ˆë‹¤', { message: err.message }));
  }
};

// ë§¤ì¥ ì²´í¬?? ?ì£¼ê°€ ?¬ì§„ ?…ë¡œ????in_progressë¡??„í™˜
export const storeCheckin = async (req, res) => {
  try {
    const storeId = req.storeId;
    const { id } = req.params;
    const { photoUrls = [] } = req.body;

    const reservation = await findStoreReservation(id, storeId);
    if (!reservation) {
      return res.status(404).json(error('RESERVATION_NOT_FOUND', '¿¹¾àÀ» Ã£À» ¼ö ¾ø½À´Ï´Ù'));
    }
    if (reservation.status !== 'confirmed' && reservation.status !== 'in_progress') {
      return res
        .status(400)
        .json(error('INVALID_STATUS', 'Ã¼Å©ÀÎ °¡´ÉÇÑ »óÅÂ°¡ ¾Æ´Õ´Ï´Ù', { currentStatus: reservation.status }));
    }

    const mergedPhotos = mergePhotoUrls(reservation.luggage_image_urls, photoUrls);

    await query(
      UPDATE reservations
       SET status = 'in_progress',
           actual_start_time = COALESCE(actual_start_time, NOW()),
           luggage_image_urls = ?,
           updated_at = NOW()
       WHERE id = ? AND store_id = ?,
      [mergedPhotos.length ? JSON.stringify(mergedPhotos) : null, id, storeId]
    );

    // ÀÚµ¿ ¹ß±Ş ÈÅ: Ã¼Å©ÀÎ ¿Ï·á(¸ÅÀå Ãø)
    try {
      await issueCouponsForTrigger({
        customerId: reservation.customer_id,
        storeId,
        trigger: 'checkin_completed',
        reservationId: reservation.id,
      });
    } catch (hookErr) {
      console.warn('[storeCheckin] auto issue skipped:', hookErr?.message);
    }

    return res.json(success({ id, status: 'in_progress', photos: mergedPhotos }, 'Ã¼Å©ÀÎÀÌ ¿Ï·áµÇ¾ú½À´Ï´Ù'));
  } catch (err) {
    console.error('[storeCheckin] error:', err);
    return res.status(500).json(error('INTERNAL_ERROR', '¼­¹ö ¿À·ù°¡ ¹ß»ıÇß½À´Ï´Ù', { message: err.message }));
  }
};
// ë³´ê???? ë‹¹: ê²¹ì¹˜???ˆì•½???†ëŠ” available ë³´ê??¨ì„ ?˜ë‚˜ ? íƒ
const assignAvailableStorage = async (storeId, startTime, endTime, storageType) => {
  const rows = await query(
    `SELECT s.id, s.number
     FROM storages s
     WHERE s.store_id = ?
       AND s.status = 'available'
       AND s.type = ?
       AND NOT EXISTS (
         SELECT 1 FROM reservations r
         WHERE r.storage_id = s.id
           AND r.status IN ('confirmed','in_progress')
           AND r.start_time < ?
           AND r.end_time > ?
       )
     ORDER BY s.number
     LIMIT 1`,
    [storeId, storageType, endTime, startTime]
  );
  return rows && rows.length > 0 ? rows[0] : null;
};

const releaseStorageIfAny = async (reservation) => {
  if (reservation?.storage_id) {
    await query('UPDATE storages SET status = ? WHERE id = ?', ['available', reservation.storage_id]);
  }
};

const mergePhotoUrls = (existingJson, newUrls) => {
  try {
    const current = existingJson ? JSON.parse(existingJson) : [];
    if (!Array.isArray(current)) return newUrls || [];
    return [...current, ...(newUrls || [])];
  } catch {
    return newUrls || [];
  }
};

// ë§¤ì¥???¬í¼: ?¹ì • ?ˆì•½ ì¡°íšŒ (store ê¸°ì?)
const findStoreReservation = async (reservationId, storeId) => {
  const rows = await query(
    `SELECT id, store_id, customer_id, status, start_time, end_time, storage_id, storage_number, requested_storage_type, luggage_image_urls
     FROM reservations WHERE id = ? AND store_id = ? LIMIT 1`,
    [reservationId, storeId]
  );
  return rows && rows.length > 0 ? rows[0] : null;
};

// ê³ ê°???¬í¼: ?¹ì • ê³ ê°???ˆì•½ ì¡°íšŒ
const findCustomerReservation = async (reservationId, customerId) => {
  const rows = await query(
    `SELECT id, store_id, customer_id, status, start_time, end_time, storage_id, storage_number, requested_storage_type
     FROM reservations WHERE id = ? AND customer_id = ? LIMIT 1`,
    [reservationId, customerId]
  );
  return rows && rows.length > 0 ? rows[0] : null;
};

export const approveReservation = async (req, res) => {
  try {
    const storeId = req.storeId;
    const { id } = req.params;
    const rows = await query(
      `SELECT id, store_id, status, start_time, end_time, storage_id, storage_number, requested_storage_type
       FROM reservations WHERE id = ? AND store_id = ? LIMIT 1`,
      [id, storeId]
    );
    if (!rows || rows.length === 0) {
      return res.status(404).json(error('RESERVATION_NOT_FOUND', '?ˆì•½??ì°¾ì„ ???†ìŠµ?ˆë‹¤'));
    }
    const reservation = rows[0];
    const startTime = reservation.start_time;
    const endTime = reservation.end_time;
    const storageType = reservation.requested_storage_type;

    // ?´ë? ?€?¥ëœ ë³´ê??¨ì´ ?†ìœ¼ë©??ˆë¡œ ? ë‹¹
    let storageId = reservation.storage_id;
    let storageNumber = reservation.storage_number;
    if (!storageId) {
      const available = await assignAvailableStorage(storeId, startTime, endTime, storageType);
      if (!available) {
        return res
          .status(409)
          .json(error('NO_AVAILABLE_STORAGE', '?´ë‹¹ ?œê°„???¬ìš© ê°€?¥í•œ ë³´ê??¨ì´ ?†ìŠµ?ˆë‹¤', { storeId, startTime, endTime }));
      }
      storageId = available.id;
      storageNumber = available.number;
      await query('UPDATE storages SET status = ?, updated_at = NOW() WHERE id = ?', ['occupied', storageId]);
    }

    await query(
      `UPDATE reservations
       SET status = 'confirmed', storage_id = ?, storage_number = ?, updated_at = NOW()
       WHERE id = ? AND store_id = ?`,
      [storageId, storageNumber, id, storeId]
    );

    return res.json(
      success({ id, status: 'confirmed', storageId, storageNumber }, '?ˆì•½???¹ì¸?˜ì—ˆê³?ë³´ê??¨ì´ ë°°ì •?˜ì—ˆ?µë‹ˆ??)
    );
  } catch (err) {
    console.error('[approveReservation] error:', err);
    return res.status(500).json(error('INTERNAL_ERROR', '?œë²„ ?¤ë¥˜ê°€ ë°œìƒ?ˆìŠµ?ˆë‹¤', { message: err.message }));
  }
};

const updateStatus = async (req, res, newStatus, successMessage) => {
  const { id } = req.params;
  const storeId = req.storeId;
  try {
    if (!ALLOWED_STATUSES.includes(newStatus)) {
      return res
        .status(400)
        .json(error('VALIDATION_ERROR', '?ˆìš©?˜ì? ?ŠëŠ” ?íƒœ?…ë‹ˆ??, { allowed: ALLOWED_STATUSES, received: newStatus }));
    }

    const rows = await query(
      'SELECT id, store_id, storage_id FROM reservations WHERE id = ? AND store_id = ? LIMIT 1',
      [id, storeId]
    );
    const reservation = rows && rows.length > 0 ? rows[0] : null;
    if (!reservation) {
      return res.status(404).json(error('RESERVATION_NOT_FOUND', '?ˆì•½??ì°¾ì„ ???†ìŠµ?ˆë‹¤'));
    }

    const result = await query('UPDATE reservations SET status = ?, updated_at = NOW() WHERE id = ? AND store_id = ?', [
      newStatus,
      id,
      storeId,
    ]);

    // ?„ë£Œ/ë°˜ë‚©/ì·¨ì†Œ/ê±°ì ˆ ??ë³´ê???ë°˜í™˜
    const shouldRelease = ['cancelled', 'rejected', 'completed', 'returned'].includes(newStatus);
    if (shouldRelease && reservation?.storage_id) {
      await query('UPDATE storages SET status = ? WHERE id = ?', ['available', reservation.storage_id]);
    }

    return res.json(success({ id, status: newStatus }, successMessage));
  } catch (err) {
    console.error(`[updateStatus:${newStatus}] error:`, err);
    return res.status(500).json(error('INTERNAL_ERROR', '?œë²„ ?¤ë¥˜ê°€ ë°œìƒ?ˆìŠµ?ˆë‹¤', { message: err.message }));
  }
};

export const rejectReservation = (req, res) => updateStatus(req, res, 'rejected', '?ˆì•½??ê±°ì ˆ?˜ì—ˆ?µë‹ˆ??);
export const cancelReservation = (req, res) => updateStatus(req, res, 'cancelled', '?ˆì•½??ì·¨ì†Œ?˜ì—ˆ?µë‹ˆ??);

export const updateReservationStatus = (req, res) => {
  let newStatus = (req.body.status || '').trim();
  if (!newStatus) {
    return res.status(400).json(error('VALIDATION_ERROR', 'ë³€ê²½í•  ?íƒœê°€ ?„ìš”?©ë‹ˆ??, { required: ['status'] }));
  }
  // ?¸í™˜ ?íƒœê°?ë§¤í•‘ (?¤í‚¤ë§ˆì— ?†ëŠ” approved/active ?±ì„ ?•í•© ê°’ìœ¼ë¡?ë³€??
  const normalize = {
    approved: 'confirmed',
    active: 'in_progress',
  };
  if (normalize[newStatus]) {
    newStatus = normalize[newStatus];
  }

    // confirmed ?”ì²­???¤ë©´ ë³´ê???ë°°ì •ê¹Œì? ?˜í–‰?˜ëŠ” approveReservation ë¡œì§???¬ì‚¬??  if (newStatus === 'confirmed') {
    return approveReservation(req, res);
  }

  return updateStatus(req, res, newStatus, '?ˆì•½ ?íƒœê°€ ë³€ê²½ë˜?ˆìŠµ?ˆë‹¤');
};


